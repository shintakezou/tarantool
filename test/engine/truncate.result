test_run = require('test_run').new()
---
...
engine = test_run:get_cfg('engine')
---
...
fiber =  require('fiber')
---
...
--
-- Check truncate_count space option behavior.
--
NAME = 3
---
...
OPTS = 6
---
...
s = box.schema.create_space('test', {engine = engine})
---
...
_ = s:create_index('pk')
---
...
-- Initially truncate_count is unset.
box.space._space:get(s.id)[OPTS].truncate_count
---
- null
...
-- Simultaneous truncate + alter is forbidden.
_ = box.space._space:update(s.id, {{'=', OPTS, {truncate_count = 1}}, {'=', NAME, 'xyz'}})
---
- error: 'Can''t modify space ''xyz'': can''t truncate and alter space at the same
    time'
...
-- truncate_count must be >= 0.
_ = box.space._space:update(s.id, {{'=', OPTS, {truncate_count = -1}}})
---
- error: 'Can''t modify space ''test'': truncate count must be >= 0'
...
-- truncate_count may only be incremented by 1.
_ = box.space._space:update(s.id, {{'=', OPTS, {truncate_count = 2}}})
---
- error: 'Can''t modify space ''test'': invalid truncate count usage'
...
-- Bumping truncate_count triggers space truncation.
_ = s:insert{123}
---
...
_ = box.space._space:update(s.id, {{'=', OPTS, {truncate_count = 1}}})
---
...
s:select()
---
- []
...
-- Space truncation bumps truncate_count.
_ = s:insert{123}
---
...
s:truncate()
---
...
box.space._space:get(s.id)[OPTS].truncate_count
---
- 2
...
-- truncate_count cannot be decremented.
_ = box.space._space:update(s.id, {{'=', OPTS, {truncate_count = 1}}})
---
- error: 'Can''t modify space ''test'': invalid truncate count usage'
...
s:drop()
---
...
--
-- Truncate space with no indexes.
--
s = box.schema.create_space('test', {engine = engine})
---
...
s:truncate()
---
...
s:drop()
---
...
--
-- Truncate empty space.
--
s = box.schema.create_space('test', {engine = engine})
---
...
_ = s:create_index('pk')
---
...
s:truncate()
---
...
s:select()
---
- []
...
s:drop()
---
...
--
-- Truncate non-empty space.
--
s = box.schema.create_space('test', {engine = engine})
---
...
_ = s:create_index('i1', {parts = {1, 'unsigned'}})
---
...
_ = s:create_index('i2', {parts = {2, 'unsigned'}})
---
...
_ = s:create_index('i3', {parts = {3, 'string'}})
---
...
_ = s:insert{1, 3, 'a'}
---
...
_ = s:insert{2, 2, 'b'}
---
...
_ = s:insert{3, 1, 'c'}
---
...
s:truncate()
---
...
s.index.i1:select()
---
- []
...
s.index.i2:select()
---
- []
...
s.index.i3:select()
---
- []
...
_ = s:insert{10, 30, 'x'}
---
...
_ = s:insert{20, 20, 'y'}
---
...
_ = s:insert{30, 10, 'z'}
---
...
s.index.i1:select()
---
- - [10, 30, 'x']
  - [20, 20, 'y']
  - [30, 10, 'z']
...
s.index.i2:select()
---
- - [30, 10, 'z']
  - [20, 20, 'y']
  - [10, 30, 'x']
...
s.index.i3:select()
---
- - [10, 30, 'x']
  - [20, 20, 'y']
  - [30, 10, 'z']
...
s:drop()
---
...
--
-- Check that space truncation is linearizable.
--
-- Create a space with several indexes and start three fibers:
-- 1st and 3rd update the space, 2nd truncates it. Then wait
-- until all fibers are done. The space should contain data
-- inserted by the 3rd fiber.
--
-- Note, this is guaranteed to be true only if space updates
-- don't yield, which is always true for memtx and is true
-- for vinyl in case there's no data on disk, as in this case.
--
s = box.schema.create_space('test', {engine = engine})
---
...
_ = s:create_index('i1', {parts = {1, 'unsigned'}})
---
...
_ = s:create_index('i2', {parts = {2, 'unsigned'}})
---
...
_ = s:create_index('i3', {parts = {3, 'string'}})
---
...
_ = s:insert{1, 1, 'a'}
---
...
_ = s:insert{2, 2, 'b'}
---
...
_ = s:insert{3, 3, 'c'}
---
...
c = fiber.channel(3)
---
...
test_run:cmd("setopt delimiter ';'")
---
- true
...
fiber.create(function()
    box.begin()
    s:replace{1, 10, 'aa'}
    s:replace{2, 20, 'bb'}
    s:replace{3, 30, 'cc'}
    box.commit()
    c:put(true)
end)
fiber.create(function()
    s:truncate()
    c:put(true)
end)
fiber.create(function()
    box.begin()
    s:replace{1, 100, 'aaa'}
    s:replace{2, 200, 'bbb'}
    s:replace{3, 300, 'ccc'}
    box.commit()
    c:put(true)
end)
test_run:cmd("setopt delimiter ''");
---
...
for i = 1, 3 do c:get() end
---
...
s.index.i1:select()
---
- - [1, 100, 'aaa']
  - [2, 200, 'bbb']
  - [3, 300, 'ccc']
...
s.index.i2:select()
---
- - [1, 100, 'aaa']
  - [2, 200, 'bbb']
  - [3, 300, 'ccc']
...
s.index.i3:select()
---
- - [1, 100, 'aaa']
  - [2, 200, 'bbb']
  - [3, 300, 'ccc']
...
s:drop()
---
...
--
-- Check that space truncation is persistent.
--
-- The test checks the following cases:
-- - Create and truncate before snapshot
-- - Create before snapshot, truncate after snapshot
-- - Create and truncate after snapshot
--
s1 = box.schema.create_space('test1', {engine = engine})
---
...
_ = s1:create_index('i1', {parts = {1, 'unsigned'}})
---
...
_ = s1:create_index('i2', {parts = {2, 'unsigned'}})
---
...
_ = s1:insert{1, 3}
---
...
_ = s1:insert{2, 2}
---
...
_ = s1:insert{3, 1}
---
...
s1:truncate()
---
...
_ = s1:insert{123, 321}
---
...
s2 = box.schema.create_space('test2', {engine = engine})
---
...
_ = s2:create_index('i1', {parts = {1, 'unsigned'}})
---
...
_ = s2:create_index('i2', {parts = {2, 'unsigned'}})
---
...
_ = s2:insert{10, 30}
---
...
_ = s2:insert{20, 20}
---
...
_ = s2:insert{30, 10}
---
...
box.snapshot()
---
- ok
...
s2:truncate()
---
...
_ = s2:insert{456, 654}
---
...
s3 = box.schema.create_space('test3', {engine = engine})
---
...
_ = s3:create_index('i1', {parts = {1, 'unsigned'}})
---
...
_ = s3:create_index('i2', {parts = {2, 'unsigned'}})
---
...
_ = s3:insert{100, 300}
---
...
_ = s3:insert{200, 200}
---
...
_ = s3:insert{300, 100}
---
...
s3:truncate()
---
...
_ = s3:insert{789, 987}
---
...
test_run:cmd('restart server default')
s1 = box.space.test1
---
...
s2 = box.space.test2
---
...
s3 = box.space.test3
---
...
s1.index.i1:select()
---
- - [123, 321]
...
s1.index.i2:select()
---
- - [123, 321]
...
s2.index.i1:select()
---
- - [456, 654]
...
s2.index.i2:select()
---
- - [456, 654]
...
s3.index.i1:select()
---
- - [789, 987]
...
s3.index.i2:select()
---
- - [789, 987]
...
s1:drop()
---
...
s2:drop()
---
...
s3:drop()
---
...
